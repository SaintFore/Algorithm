# 为什么 `sqrt(-10)` 产生这些结果

## 第一部分：负数平方根赋值给整数变量

```c
int t1;
t1 = sqrt(-10);
printf("%d\n",t1); //-2147483648
printf("%f\n",t1); //0.000000
```

### 为什么会这样？

1. **`sqrt(-10)` 的结果**:
   - 数学上，负数的平方根是复数，C语言的 `sqrt()` 函数无法返回复数
   - 根据 C 标准，这是未定义行为，但大多数实现会返回特殊值 `NaN`（Not a Number）
   - `NaN` 是一个特殊的浮点值，表示无效的数学操作

2. **为什么 `t1` 是 `-2147483648`**:
   - 当 `NaN` 被赋值给整数变量 `t1` 时，发生了从浮点到整数的类型转换
   - 这种转换会截断小数部分，并且结果是实现定义的
   - 在很多实现中，`NaN` 转换为整数会得到最小整数值 `-2147483648`（INT_MIN）

3. **为什么 `printf("%f\n",t1)` 显示 `0.000000`**:
   - 这里有格式说明符不匹配问题
   - `%f` 期望一个浮点数参数，但提供的是整数 `t1`
   - 整数 `-2147483648` 的二进制表示，当按浮点数解释时，可能会显示为 `0.000000`

## 第二部分：负数平方根赋值给浮点变量

```c
float t2;
t2 = sqrt(-10);
printf("%d\n",t2); //0
printf("%f\n",t2); //这个是正确答案
```

### 为什么会这样？

1. **`t2 = sqrt(-10)` 的结果**:
   - `sqrt(-10)` 返回 `NaN`，并且直接赋值给 `float` 类型的 `t2`
   - `t2` 现在包含特殊值 `NaN`

2. **为什么 `printf("%d\n",t2)` 显示 `0`**:
   - 格式说明符不匹配：`%d` 期望整数，但 `t2` 是浮点数
   - 当浮点数 `NaN` 被错误地以整数方式打印时，许多实现会显示 `0`

3. **为什么 `printf("%f\n",t2)` 显示 `nan`（或类似结果）**:
   - 这是正确的格式说明符，`%f` 用于浮点数
   - 因此它会正确显示 `NaN`（显示为 "nan"）



