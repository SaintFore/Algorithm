# 字符串的最小表示法：循环同构字符串的最优表示

在字符串处理领域，有一个有趣的问题叫做"字符串的最小表示法"或"循环同构字符串的字典序最小表示"。今天，我将通过分析一段简洁而优雅的C代码，带大家深入理解这个问题及其解决方案。

## 问题背景

首先，让我们明确什么是"循环同构"字符串：

> 如果一个字符串可以通过将其首部的若干个字符移到末尾得到另一个字符串，则这两个字符串被称为循环同构的。

例如，"HELLO"、"ELLOH"、"LLOHE"、"LOHEL"和"OHELL"都是循环同构的。

在这个问题中，我们的目标是：对于一个给定的字符串，找到它所有循环同构串中字典序最小的一个。

## 代码实现

以下是实现这一功能的C代码：

```c
#include<stdio.h>
#include<string.h>
#define maxn 105

int less(const char* s, int p, int q){
    int n = strlen(s);
    for(int i = 0; i < n; i++){
        if(s[(p+i)%n] != s[(q+i)%n]) return s[(p+i)%n] < s[(q+i)%n];
    }
    return 0;
}

int main(){
    int T;
    char s[maxn];
    scanf("%d",&T);
    while(T--){
        scanf("%s",s);
        int ans = 0;
        int n = strlen(s);
        for(int i = 1; i < n; i++){
            if(less(s, i, ans)) ans = i;
        }
        for(int i = 0; i < n; i++){
            putchar(s[(i+ans)%n]);
        }
        putchar('\n');
    }
    return 0;
}
```

## 代码详细分析

### 1. `less` 函数 - 比较两个循环子串

```c
int less(const char* s, int p, int q){
    int n = strlen(s);
    for(int i = 0; i < n; i++){
        if(s[(p+i)%n] != s[(q+i)%n]) return s[(p+i)%n] < s[(q+i)%n];
    }
    return 0;
}
```

这个函数是算法的核心，它判断从位置p开始的循环子串是否字典序小于从位置q开始的循环子串：

1. 获取原字符串的长度n
2. 依次比较两个子串对应位置的字符：
   - 使用`(p+i)%n`和`(q+i)%n`来处理循环索引
   - 当遇到第一个不相等的字符时，返回它们的大小比较结果
3. 如果所有字符都相等（两个子串完全相同），返回0表示不小于

这个函数巧妙地处理了字符串的循环性质，确保了即使索引超出字符串范围也能正确比较。

### 2. 主函数逻辑

```c
int main(){
    int T;
    char s[maxn];
    scanf("%d",&T);
    while(T--){
        scanf("%s",s);
        int ans = 0;
        int n = strlen(s);
        for(int i = 1; i < n; i++){
            if(less(s, i, ans)) ans = i;
        }
        for(int i = 0; i < n; i++){
            putchar(s[(i+ans)%n]);
        }
        putchar('\n');
    }
    return 0;
}
```

主函数实现了多个测试用例的处理：

1. 读取测试用例数量T
2. 对于每个测试用例：
   - 读取字符串s
   - 初始化`ans=0`，假设从位置0开始的循环子串是字典序最小的
   - 遍历所有可能的起始位置（1到n-1）
   - 如果找到更小的表示法（`less(s, i, ans)`返回真），则更新`ans`
   - 最后，输出从位置`ans`开始的循环子串，即字典序最小的表示

## 算法思想解析

### 暴力比较策略

这个算法采用了暴力比较的策略，但实现非常简洁而优雅。其核心思想是：

1. 考虑字符串的所有可能循环移位（共n种，其中n是字符串长度）
2. 找到字典序最小的那个移位
3. 输出该移位表示的字符串

### 时间复杂度分析

- 对于`less`函数：最坏情况下需要比较n个字符，时间复杂度为O(n)
- 主函数中调用`less`函数进行n-1次比较，总时间复杂度为O(n²)
- 对于T个测试用例，总体时间复杂度为O(T·n²)

虽然有更优的算法（如双指针技术）可以将时间复杂度优化到O(n)，但这个简单的实现对于较短的字符串已经足够高效，而且思路清晰易懂。

## 算法应用示例

让我们以字符串"CYCLIC"为例，看看算法是如何工作的：

1. 初始化`ans=0`，当前最小表示为"CYCLIC"
2. 比较"YCLICC"与"CYCLIC"，"Y">"C"，所以不更新
3. 比较"CLICCYY"与"CYCLIC"，"C"="C"，"L">"Y"，所以不更新
4. 比较"LICCYC"与"CYCLIC"，"L">"C"，所以不更新
5. 比较"ICCYCL"与"CYCLIC"，"I">"C"，所以不更新
6. 比较"CCYCLI"与"CYCLIC"，"C"="C"，"C"<"Y"，所以更新`ans=5`
7. 最终结果为"CCYCLI"，这是字典序最小的表示

## 实用价值与应用场景

这种"最小表示法"算法在以下场景中特别有用：

1. **字符串哈希**：用于检测循环同构字符串，可以将所有循环同构的字符串映射到唯一的"规范表示"
2. **压缩算法**：某些特定情境下的字符串压缩
3. **字符串模式匹配**：在某些循环匹配问题中作为预处理步骤
4. **生物信息学**：在DNA序列分析中，有时需要确定环状DNA的标准表示形式

## 优化思路

虽然当前算法已经相当简洁，但还有一些可能的优化方向：

1. **避免重复计算字符串长度**：将strlen(s)的结果缓存，避免在less函数中重复计算
2. **使用双指针法**：可以将时间复杂度降低到O(n)，对于长字符串更有效率
3. **内存优化**：如果需要处理非常长的字符串，可以动态分配内存而不是使用固定大小的数组

## 总结

这段代码通过一个简洁优雅的实现，解决了字符串循环同构的最小表示问题。它展示了几个重要的编程思想：

1. **模运算处理循环结构**：使用`%`运算符巧妙处理字符串的循环特性
2. **增量式比较**：仅在遇到第一个不同字符时决定大小关系
3. **贪心策略**：始终保持当前找到的最小表示

这些技巧和思想不仅适用于这个特定问题，也可以应用到其他字符串处理和算法设计中，是编程工具箱中的宝贵资产。

---

**编程挑战**: 尝试改进上述代码，实现一个时间复杂度为O(n)的算法来解决相同的问题。提示：考虑使用类似于KMP算法中的"失配函数"思想。
